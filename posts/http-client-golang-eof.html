<html>

<head>
  <title>Pooling HTTP client | Tam's Blog</title>
  <meta charset="utf-8">
  <meta http-equiv="content-type" content="text/html;">
  <meta name=viewport content="initial-scale=1.0 maximum-scale=1.0">
  <meta property='og:image' content='https://melancholy.com/img/default.jpg'>
  <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
  <link rel="manifest" href="../manifest.json">
  <link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin-ext,vietnamese"
    rel="stylesheet">
  <link href="../css/theme.css?t=" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="../css/highlight/tomorrow.css">
  <link rel="stylesheet" href="../css/fontello.css">
  <link rel="stylesheet" href="../emoji/css/emoji.dist.css">
  <link rel="stylesheet" href="../emoji/css/emojione.min.css">
  <link rel="stylesheet" href="../emoji/css/messenger.min.css">
  <link rel="stylesheet" href="../emoji/css/thinking.ext.css">
  <script src="../js/highlight.pack.js"></script>
  <script src="../js/autosizing.js"></script>
  <script src="../js/fetch.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</head>

<body>
  <div class="header">
    <a href="/"><span class="avatar"></span><span class="header-link">Tam's Blog</span></a>
  </div>
  <div class="container">
    <div class="main">
      <p><a href="/">&lt;- Quay v·ªÅ trang ch·ªß</a></p>
      <h1>Pooling HTTP client</h1>
      <!-- `HTTP` is a application protocol based on TCP transport (layer 4 OSI), I have a related post [[TCP Close connection](https://notes-ngtam.pages.dev/posts/close-tcp)], you could read it before going ahead. -->
<p><code>HTTP</code> l√† 1 giao th·ª©c ·ªü t·∫ßng ·ª©ng d·ª•ng (application) s·ª≠ d·ª•ng giao th·ª©c <code>TCP</code> ·ªü t·∫ßng v·∫≠n chuy·ªÉn (transport), tr∆∞·ªõc ƒë√≥ m√¨nh c≈©ng c√≥ vi·∫øt 1 b√†i li√™n quan ƒë·∫øn <code>TCP</code>, b·∫°n c√≥ th·ªÉ ƒë·ªçc tr∆∞·ªõc [<a href="https://notes-ngtam.pages.dev/posts/close-tcp">TCP Close connection</a>].</p>
<!-- ## Why do we want to reuse connection? -->
<h2><a href="#pooling" aria-hidden="true" class="anchor" id="pooling"></a>Pooling</h2>
<!-- We all heard about `pooling technique`, from `HTTP` to `GRPC`, database connection, it's very popular. T -->
<p>HTTP l√† m·ªôt giao th·ª©c <code>client-server</code> d·ª±a tr√™n <code>TCP</code>, ƒë·ªÉ th·ª±c thi 1 y√™u c·∫ßu, ph√≠a <code>client</code> s·∫Ω c·∫ßn kh·ªüi t·∫°o <code>TCP</code> connection t·ªõi <code>server</code> b·∫±ng c∆° ch·∫ø b·∫Øt tay 3 b∆∞·ªõc (<code>3-way handshake</code>), <code>SYN -&gt; SYN/ACK -&gt; SYN</code>, ngo√†i ra, n·∫øu s·ª≠ d·ª•ng TLS th√¨ sau qu√° tr√¨nh tr√™n c√≤n di·ªÖn ra th√™m qu√° tr√¨nh trao ƒë·ªïi kho√° ƒë·ªÉ m√£ ho√° message, chi ph√≠ ƒë·ªÉ li√™n t·ª•c m·ªü v√† ƒë√≥ng c√°c connection l√† r·∫•t l·ªõn v√† l√£ng ph√≠ n·∫øu ·ª©ng d·ª•ng c·∫ßn g·ª≠i m·ªôt c√°ch th∆∞·ªùng xuy√™n.</p>
<p>ƒê·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y, m·ªôt kƒ© thu·∫≠t ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng r·ªông r√£i, ƒë√≥ l√† <code>pooling</code>, thay v√¨ t·∫°o m·ªõi connection m·ªói l·∫ßn g·ª≠i y√™u c·∫ßu th√¨ ch√∫ng ta s·∫Ω t·∫°o ra m·ªôt t·∫≠p c√°c connection v√† t√°i s·ª≠ d·ª•ng n√≥.</p>
<h2><a href="#http-client-trong-go" aria-hidden="true" class="anchor" id="http-client-trong-go"></a>HTTP client trong Go</h2>
<p>·ªû ph·∫ßn n√†y m√¨nh s·ª≠ d·ª•ng phi√™n b·∫£n <code>Go v1.23</code> ƒë·ªÉ ph√¢n t√≠ch.</p>
<blockquote>
<p>If the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent &quot;keep-alive&quot; request.</p>
</blockquote>
<p>Theo ph·∫ßn ch√∫ th√≠ch cho h√†m <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/net/http/client.go;l=567">Do</a>, <code>HTTP client</code> s·∫Ω t√°i s·ª≠ d·ª•ng connection ƒë·ªÉ g·ª≠i y√™u c·∫ßu ƒë·∫øn server n·∫øu client ƒë·ªçc ph·∫ßn <code>body response</code> ƒë·∫øn <code>EOF</code> trong tr∆∞·ªùng h·ª£p kh√¥ng c√≥ l·ªói x·∫£y ra.</p>
<p>ƒê·ªÉ ngƒÉn vi·ªác t√°i s·ª≠ d·ª•ng <code>TCP connection</code>, ch√∫ng ta c√≥ th·ªÉ l√†m b·∫±ng 2 c√°ch:</p>
<ol>
<li>G√°n bi·∫øn <code>Close</code> c·ªßa struct <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/net/http/request.go;l=112">Request</a> th√†nh <code>true</code> khi kh·ªüi t·∫°o 1 request m·ªõi.</li>
<li>G√°n bi·∫øn <code>DisableKeepAlives</code> c·ªßa struct <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/net/http/transport.go;l=96">Transport</a> th√†nh <code>true</code> khi kh·ªüi t·∫°o <code>HTTP client</code></li>
</ol>
<h2><a href="#v·∫•n-ƒë·ªÅ" aria-hidden="true" class="anchor" id="v·∫•n-ƒë·ªÅ"></a>V·∫•n ƒë·ªÅ</h2>
<p>Khi tri·ªÉn khai ·ª©ng d·ª•ng trong 1 th·ªùi gian d√†i, m√¨nh th·∫•y c√≥ m·ªôt v√†i API x·∫£y ra l·ªói <code>EOF</code>, l·ªói n√†y x·∫£y ra khi server v√† client ƒë·ªÅu c√≥ t√°c ƒë·ªông ƒë·∫øn connection theo 2 h∆∞·ªõng kh√°c nhau:</p>
<ul>
<li><code>server</code>: ƒë√≥ng connection b·ªüi v√¨ <code>idle timeout</code>.</li>
<li><code>client</code>: t√°i s·ª≠ d·ª•ng connection ƒë·ªÉ g·ª≠i request.</li>
</ul>
<p>Tr√≠ch d·∫´n docs t·ª´ <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/net/http/transport.go;l=96">transportReadFromServerError</a></p>
<pre><code class="language-go">// transportReadFromServerError is used by Transport.readLoop when the
// 1 byte peek read fails and we're actually anticipating a response.
// Usually this is just due to the inherent keep-alive shut down race,
// where the server closed the connection at the same time the client
// wrote. The underlying err field is usually io.EOF or some
// ECONNRESET sort of thing which varies by platform. But it might be
// the user's custom net.Conn.Read error too, so we carry it along for
// them to return from Transport.RoundTrip.
type transportReadFromServerError struct {
	err error
}
</code></pre>
<p>Khi kh·ªüi t·∫°o 1 connection m·ªõi t·ªõi server, h√†m <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/net/http/transport.go;l=1684">dialConn</a>, Go s·ª≠ d·ª•ng 2 goroutine ƒë·ªÉ ƒë·ªçc v√† vi·∫øt tr√™n m·ªói connection.</p>
<pre><code class="language-go">func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) {
    // omitted for brevity
    pconn.br = bufio.NewReaderSize(pconn, t.readBufferSize())
    pconn.bw = bufio.NewWriterSize(persistConnWriter{pconn}, t.writeBufferSize())

    go pconn.readLoop()
    go pconn.writeLoop()
    return pconn, nil
}
</code></pre>
<p>Khi th·ª±c hi·ªán request, h√†m <code>roundTrip</code> s·∫Ω t∆∞∆°ng t√°c v·ªõi 2 goroutine tr√™n th√¥ng qua channel v√† d√πng <code>select case</code> ƒë·ªÉ x·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p c√≥ th·ªÉ x·∫£y ra nh∆∞ <code>request timeout</code>, <code>read error</code>,...</p>
<pre><code class="language-go">func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error) {
    // omitted for brevity

    // Write the request concurrently with waiting for a response,
    // in case the server decides to reply before reading our full
    // request body.
    startBytesWritten := pc.nwrite
    writeErrCh := make(chan error, 1)
    pc.writech &lt;- writeRequest{req, writeErrCh, continueCh}

    resc := make(chan responseAndError)
    pc.reqch &lt;- requestAndChan{
    	treq:       req,
    	ch:         resc,
    	addedGzip:  requestedGzip,
    	continueCh: continueCh,
    	callerGone: gone,
    }

    // omitted for brevity

    for {
        testHookWaitResLoop()
        select {
        case err := &lt;-writeErrCh:
            if debugRoundTrip {
            	req.logf(&quot;writeErrCh recv: %T/%#v&quot;, err, err)
            }
            if err != nil {
            	pc.close(fmt.Errorf(&quot;write error: %w&quot;, err))
            	return nil, pc.mapRoundTripError(req, startBytesWritten, err)
            }
            if d := pc.t.ResponseHeaderTimeout; d &gt; 0 {
            	if debugRoundTrip {
            		req.logf(&quot;starting timer for %v&quot;, d)
            	}
            	timer := time.NewTimer(d)
            	defer timer.Stop() // prevent leaks
            	respHeaderTimer = timer.C
            }
        case &lt;-pcClosed:
            select {
            case re := &lt;-resc:
            	// The pconn closing raced with the response to the request,
            	// probably after the server wrote a response and immediately
            	// closed the connection. Use the response.
            	return handleResponse(re)
            default:
            }
            if debugRoundTrip {
            	req.logf(&quot;closech recv: %T %#v&quot;, pc.closed, pc.closed)
            }
            return nil, pc.mapRoundTripError(req, startBytesWritten, pc.closed)
        case &lt;-respHeaderTimer:
            if debugRoundTrip {
            	req.logf(&quot;timeout waiting for response headers.&quot;)
            }
            pc.close(errTimeout)
            return nil, errTimeout
        case re := &lt;-resc:
            return handleResponse(re)
        case &lt;-ctxDoneChan:
            select {
            case re := &lt;-resc:
            	// readLoop is responsible for canceling req.ctx after
            	// it reads the response body. Check for a response racing
            	// the context close, and use the response if available.
            	return handleResponse(re)
            default:
            }
            pc.cancelRequest(context.Cause(req.ctx))
        }
    }
}
</code></pre>
<p>V·ªõi c√°ch ho·∫°t ƒë·ªông nh∆∞ tr√™n, m√¨nh quy·∫øt ƒë·ªãnh reproduce l·ªói n√†y v·ªõi s·ª± k·∫øt h·ª£p c·ªßa c√¥ng c·ª• debug trong <code>GoLand</code>.</p>
<p>Tr∆∞·ªõc h·∫øt, c·∫•u h√¨nh <code>idle timeout</code> ·ªü server v√† client nh∆∞ sau:</p>
<pre><code class="language-go">// server
srv := &amp;http.Server{
    Addr:        &quot;:&quot; + &quot;7888&quot;,
    Handler:     handlers.CORS(originsOk, headersOk, methodsOk)(r),
    IdleTimeout: 10 * time.Second,
}

// client
func NewTransport() http.RoundTripper {
	t := http.DefaultTransport.(*http.Transport).Clone()
	t.MaxConnsPerHost = 1
	t.IdleConnTimeout = 30 * time.Second // l·ªõn h∆°n server l√† ƒë∆∞·ª£c
	t.MaxIdleConns = 1
	t.MaxIdleConnsPerHost = 1
	return t
}
</code></pre>
<p>M√¨nh s·∫Ω g·ª≠i 2 request v·ªõi ph∆∞∆°ng th·ª©c <code>POST</code> (ph∆∞∆°ng th·ª©c POST kh√¥ng c√≥ t√≠nh <code>idempotency</code>, tr√°nh HTTP client retry, c√≥ th·ªÉ xem th√™m ·ªü h√†m <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.3:src/net/http/request.go;l=1543">isReplayable</a>) v·ªõi c√°c b∆∞·ªõc:</p>
<ol>
<li>ƒë·∫∑t breakpoint sau khi l·∫•y connection t·ª´ pool v√† h√†m writeLoop, t·∫°m th·ªùi t·∫Øt t·∫•t c·∫£ breakpoint n√†y.</li>
<li>g·ª≠i th√†nh c√¥ng request ƒë·∫ßu ti√™n.</li>
<li>b·∫≠t breakpoint l√™n.</li>
<li>d·ª´ng ·ªü breakpoint sau khi l·∫•y connection, ƒë·ª£i 2 gi√¢y r·ªìi ch·∫°y ti·∫øp, t·ªõi h√†m writeLoop d·ª´ng m·ªôt nh·ªãp n·ªØa.</li>
</ol>
<p>K·∫øt qu·∫£ sau v√†i l·∫ßn th·ª≠ th√¨ m√¨nh c≈©ng l·∫•y ƒë∆∞·ª£c l·ªói <code>EOF</code> r·ªìi ~.
<img src="img/EOF_error.png" alt="EOF error" /></p>
<p>S·ª≠ d·ª•ng wireshark th√¨ th·∫•y ƒë∆∞·ª£c khi d·ª´ng ·ªü b∆∞·ªõc 4, server s·∫Ω g·ª≠i g√≥i tin <code>FIN</code> ƒë·ªÉ ƒë√≥ng <code>idle connection</code>.</p>
<p><img src="img/idle-connection-fin.png" alt="FIN packet" /></p>
<p>C√°ch t·ªët h∆°n l√† b·∫°n c√≥ th·ªÉ g·ª≠i 1 s·ªë l∆∞·ª£ng l·ªõn request v√†o nh·ªØng l√∫c server ƒë√≥ng connection, tuy nhi√™n m√¨nh th·ª≠ v√†i l·∫ßn kh√¥ng ƒë∆∞·ª£c n√™n s·ª≠ d·ª•ng c√°ch n√†y.</p>
<h2><a href="#gi·∫£i-ph√°p" aria-hidden="true" class="anchor" id="gi·∫£i-ph√°p"></a>Gi·∫£i ph√°p</h2>
<p>ƒê·ªÉ x·ª≠ l√Ω v·∫•n ƒë·ªÅ tr√™n c√≥ v√†i c√°ch sau:</p>
<ul>
<li>C·∫•u h√¨nh <code>idle timeout</code> ·ªü ph√≠a <code>client</code> th·∫•p h∆°n <code>server</code>.</li>
<li>Retry request, tuy nhi√™n ph∆∞∆°ng ph√°p n√†y c·∫ßn ƒë∆∞·ª£c c√¢n nh·∫Øc c·∫©n th·∫≠n v√¨ t√≠nh ch·∫•t <code>idempotency</code> c·ªßa request.</li>
</ul>
<h2><a href="#tham-kh·∫£o" aria-hidden="true" class="anchor" id="tham-kh·∫£o"></a>Tham kh·∫£o</h2>
<p><a href="https://medium.com/@p408865/til-go-http-client-reuse-connection-5d8c48731dec">[TIL] Go HTTP client reuse connection</a></p>
<h2><a href="#m√£-ngu·ªìn" aria-hidden="true" class="anchor" id="m√£-ngu·ªìn"></a>M√£ ngu·ªìn</h2>
<p><a href="https://github.com/dangngoctam00/go-notes/tree/main/http">[Http server &amp; client]</a></p>

      <div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='/tags/http.html'>http</a><a class='topic-tag' href='/tags/tcp.html'>tcp</a><a class='topic-tag' href='/tags/network.html'>network</a><a class='topic-tag' href='/tags/golang.html'>golang</a></div>
      <!-- <div class="copyright">
                B·∫°n ƒë∆∞·ª£c to√†n quy·ªÅn chia s·∫ª, tr√≠ch d·∫´n ho·∫∑c copy, post l·∫°i, nh∆∞ng vui l√≤ng ghi r√µ ngu·ªìn, t√°c gi·∫£ v√† kh√¥ng l√†m thay ƒë·ªïi n·ªôi dung b√†i vi·∫øt. N·∫øu kh√¥ng l√†m v·∫≠y, th√¨ OK, c≈©ng ko sao, s·∫Ω c√≥ thi√™n l√¥i thay ta d√≤m ng√≥ nh√† ng∆∞∆°i. üòà
                </div> -->
    </div>
  </div>
  <div class="footer">
    <p>Created with <i class="em em-coffee"></i> <a href="http://github.com/huytd/ristretto-rs">ristretto.rs</a></p>
    <div class="social">
      <a target="_blank" href="https://github.com/dangngoctam00"><i class="icon-github-squared"></i></a>
      <a target="_blank" href="https://www.linkedin.com/in/dang-ngoc-tam/"><i class="icon-linkedin-squared"></i></a>
    </div>
  </div>
  <script type="text/javascript" async=""
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            skipTags: ["script","noscript","style","textarea", "code"],
            ignoreClass: ["comment", "comment-list"]
          }
        });
  </script>
</body>

</html>